#+TITLE: Synthesizing Typestate Specifications in the Android Framework
#+AUTHOR: Nicholas Lewchenko
#+EMAIL: nile1033@colorado.edu
#+STARTUP: beamer
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:t
#+OPTIONS: e:t email:nil f:t inline:t num:t p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t toc:t todo:t |:t
#+CREATOR: Emacs 25.1.1 (Org mode 8.2.10)
#+DESCRIPTION: asdf
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [presentation]
#+BEAMER_THEME: Dresden
#+BEAMER_COLOR_THEME: beetle
#+COLUMNS: %45ITEM %10BEAMER_env(Env) %10BEAMER_act(Act) %4BEAMER_col(Col) %8BEAMER_opt(Opt)
#+PROPERTY: BEAMER_col_ALL 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 0.0 :ETC

#+MACRO: lstar =L*=
#+MACRO: interacts \( \longleftrightarrow \)

* Background
** Motivation
*** Motivation                                                 :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
- There's never enough documentation
- Standard minimal APIs capture the /type/, but in an OOP system it's
  helpful to understand /typestate/
- The Android Framework is an OOP focused system with plenty of
  minimal documentation
  - As well as asynchronous callbacks!
*** Framework Classes
**** Motivating Premise                                       :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.6
:END:
The typestates of many classes in the Android Framework can be
specified by *Interface Automata*

- These are not usually included with the documentation
- Could we produce them mechanically?
**** MediaPlayer                                            :B_example:BMCOL:
:PROPERTIES:
:BEAMER_env: example
:BEAMER_col: 0.4
:END:
[[./img/mediaplayer_state_diagram.png]]
** The {{{lstar}}} Algorithm
*** The {{{lstar}}} Algorithm
{{{lstar}}} is a learning algorithm for regular languages
**** Inputs
- An alphabet =A= of symbols
- A "teacher" that can answer certain questions about a regular
  language =L= over =A=
  - Membership Queries: Is this word (sequence of symbols) in =L=?
  - Equivalence Queries: Does this proposed automaton correctly
    model =L=?
**** Outputs
- A DFA that models =L=
*** Automata Variations
- The "language" of an Android Framework Class has inputs and outputs
- Would a Mealy Machine work?
- {{{lstar}}} can be trivially adapted to Mealy Machines, and several
  variations have been published
*** Interface Automata
- We actually want an "Interface Automaton"
- The use of asynchronous callbacks breaks an MM's neat pairing of
  inputs and outputs
- IAs have inputs and outputs which are not directly coupled
**** MM                                                     :B_example:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:BEAMER_env: example
:END:
[[./img/Mealy.png]]
**** IA                                                     :B_example:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:BEAMER_env: example
:END:
[[./img/ia.png]]
*** Learning Interface Automata
- translation between whole Interface Automata and Mealy Machines is
  simple
- we need to incrementally translate /membership queries/
- /Learning IO Automata/, Fides Aarts and Frits Vaandrager
- MM Learner {{{interacts}}} Transducer {{{interacts}}} IA Teacher
* DroidStar
** DroidStar                                                        :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*DroidStar* acts as a transducer, using a live Android system as an IA
Teacher, to model an MM Teacher.

- MM {{{lstar}}} implementation {{{interacts}}} DroidStar
  {{{interacts}}} Android runtime
** Inputs
*** Inputs
- The MM learner only needs an alphabet of input symbols with which to
  construct queries
- *DroidStar* needs the "meaning" of these symbols in order to perform
  translation
*** Posing a Question = Writing a Learning Purpose                  :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
- A abstraction of the actual IO system that we intend to learn
- Implemented in DroidStar with the =LearningPurpose= interface
- Defines the full list of inputs and outputs, as well as their
  semantics (as concrete method calls)
- The "user interface" of the system
** Outputs
*** Outputs: Interface Automata
- Interface automata, tagged with the symbol names defined in the
  =LearningPurpose= implementation
- Currently written directly as a graphviz =dot= graph
- Also, metadata about the learning session
**** SpeechRec                                              :B_example:BMCOL:
:PROPERTIES:
:BEAMER_env: example
:BEAMER_col: 0.6
:END:
[[./img/SpeechRecognizer-diagram.png]]
**** Timer                                                  :B_example:BMCOL:
:PROPERTIES:
:BEAMER_env: example
:BEAMER_col: 0.3
:END:
[[./img/CountDownTimer-diagram.png]]
* Future Work
** Implementation
*** Future Work: Implementation Improvements                        :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
- Re-implement =LearningPurpose= interface in Scala
- Better handling of non-determinism
** New Problems
*** Future Work: Extending to New Problems                          :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
- outputs currently useful for documentation
- could they be used for verification?
- could the "inputs" be better automated?
*** General Queries
- We can ask questions other than Typestate
- What other questions are useful?
- Can the =LearningPurpose= be redesigned to be more general?
  - Finer "syntax controls" on alphabet
*** Non-Typestate Examples
**** SQL                                                    :B_example:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:BEAMER_env: example
:END:
[[./img/SQLiteOpenHelper-diagram.png]]
**** FileObserver                                           :B_example:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:BEAMER_env: example
:END:
[[./img/FileObserver-diagram.png]]
*** Method Sequence Verification
- An Interface Automaton describes "valid" I/O sequences
- Method sequences could be mined from apps
- What would be a more directly useful automata format?
  - How useful is graphviz =dot=?
  - simple json or yaml?
*** Synthesizing Queries
Can we reduce the work required to write a =LearningPurpose=?
**** Possibilities                                                  :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
- Mining input and output symbols from documentation or apps
- Detect and suggest resolution for non-determinism
- Autoconfig other values (such as the no-output timeout)
